<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Last Country Standing — Draft Order</title>
  <style>
    html,body{height:100%;margin:0;background:#000;color:#fff;font-family:monospace}
    .wrap{max-width:1200px;margin:14px auto;text-align:center}
    canvas{display:block;margin:12px auto;border:3px solid rgba(255,255,255,0.06);box-shadow:0 8px 30px rgba(0,0,0,0.7)}
    #overlay{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.75);color:#fff;padding:20px;border-radius:8px;display:none;min-width:320px}
    #overlay h2{margin:0 0 10px 0}
    #controls{margin-top:6px}
    button{background:#0b6;padding:8px 12px;border:none;border-radius:6px;cursor:pointer}
    button.secondary{background:#555}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Last Country Standing — Draft Order</h1>
    <canvas id="gameCanvas" width="1000" height="600"></canvas>
    <div id="controls">
      <button id="resetBtn" class="secondary">Reset</button>
      <button id="startBtn">Start</button>
    </div>
  </div>
  <div id="overlay"></div>

  <script>
  (function(){
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const resetBtn = document.getElementById('resetBtn');
    const startBtn = document.getElementById('startBtn');

    // ====== Configurable parameters ======
    const PLAYERS = [
      'Jeff', 'Glenn', 'John', 'Mike', 'Farrad', 'Dave',
      'Allyson', 'Jerry', 'Jim', 'Todd', 'Scott', 'Matt'
    ];

    const COUNTRY_STYLES = [' Republic', 'land', 'stan', 'ovia', ' Isles', ' Federation', ' Dominion'];

    const LAUNCH_MIN_MS = 2600; // min time between launches
    const LAUNCH_MAX_MS = 5100; // max time between launches
    const TRAVEL_MIN_S = 3.6;   // min travel time (seconds)
    const TRAVEL_MAX_S = 6.6;   // max travel time (seconds)

    const MARKER_RADIUS = 10;
    const FONT = '13px monospace';

    // ====== State ======
    let countries = [];
    let missiles = [];
    let explosions = [];
    let eliminated = []; // elimination order (first eliminated first)
    let running = false;

    let lastTime = performance.now();
    let lastLaunchTime = 0;
    let nextLaunchDelay = rand(LAUNCH_MIN_MS, LAUNCH_MAX_MS);

    // Background world map (Mercator projection). We set crossOrigin for safer use.
    const backgroundImg = new Image();
    backgroundImg.crossOrigin = 'anonymous';
    backgroundImg.src = 'https://upload.wikimedia.org/wikipedia/commons/8/80/World_map_-_low_resolution.svg';
    let bgLoaded = false;
    backgroundImg.onload = () => { bgLoaded = true; }

    // ====== Helpers ======
    function rand(min, max){ return Math.random() * (max - min) + min }
    function choice(arr){ return arr[Math.floor(Math.random()*arr.length)] }

    function quadraticPoint(p0,p1,p2,t){
      const u = 1 - t;
      const tt = t*t;
      const uu = u*u;
      return {
        x: uu*p0.x + 2*u*t*p1.x + tt*p2.x,
        y: uu*p0.y + 2*u*t*p1.y + tt*p2.y
      }
    }

    // ====== Sound Functions ======

    // Simple beep function for 8-bit style sound
    function playBeep(freq=440, duration=120, volume=0.1){
      try {
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        oscillator.type = 'square'; // 8-bit style wave
        oscillator.frequency.value = freq;
        gainNode.gain.value = volume;

        oscillator.start();

        setTimeout(() => {
          oscillator.stop();
          audioCtx.close();
        }, duration);
      } catch(e){ /* ignore on error */ }
    }

    // Explosion sound with noise burst
    function playExplosion(){
      try {
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const bufferSize = audioCtx.sampleRate;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);

        // Fill buffer with white noise
        for(let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2); // fade out
        }

        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;

        const gainNode = audioCtx.createGain();
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);

        noise.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        noise.start();
        noise.stop(audioCtx.currentTime + 0.3);

        setTimeout(() => audioCtx.close(), 500);
      } catch(e){ /* ignore on error */ }
    }

    // ====== Init / Reset ======
    function makeCountryName(base){
      const suf = choice(COUNTRY_STYLES);
      return base + suf;
    }

    function initCountries(){
      countries = [];
      eliminated = [];
      missiles = [];
      explosions = [];

      const cols = 4;
      const rows = Math.ceil(PLAYERS.length / cols);
      const marginX = 80;
      const marginY = 60;
      const xSpacing = (canvas.width - marginX*2) / (cols - 1 || 1);
      const ySpacing = (canvas.height - marginY*2) / (rows - 1 || 1);
      let index = 0;
      for (let r=0; r<rows; r++){
        for (let c=0; c<cols; c++){
          if (index >= PLAYERS.length) break;
          const x = marginX + c * xSpacing;
          const y = marginY + r * ySpacing;
          countries.push({
            id: index,
            name: makeCountryName(PLAYERS[index]),
            short: PLAYERS[index],
            x, y,
            alive: true
          });
          index++;
        }
      }
    }

    function resetGame(){
      running = false;
      initCountries();
      overlay.style.display = 'none';
      lastTime = performance.now();
      lastLaunchTime = lastTime;
      nextLaunchDelay = rand(LAUNCH_MIN_MS, LAUNCH_MAX_MS);
      startBtn.disabled = false;
      draw();
    }

    // ====== Launching / Simulation ======
    function pickAttackerAndTarget(){
      const alive = countries.filter(c=>c.alive);
      if (alive.length <= 1) return null;
      const attacker = choice(alive);
      let target = choice(alive);
      while (target === attacker) target = choice(alive);
      return {attacker, target};
    }

    function launchMissile(attacker, target){
      const sx = attacker.x;
      const sy = attacker.y;
      const ex = target.x;
      const ey = target.y;

      // Control point — make a high arch above the two points, with some randomness
      const mx = (sx + ex) / 2 + rand(-80, 80);
      const my = Math.min(sy, ey) - rand(140, 260); // high arc

      const travel = rand(TRAVEL_MIN_S, TRAVEL_MAX_S); // seconds
      const speed = 1 / travel; // progress per second

      const color = `hsl(${Math.floor(rand(0,360))}deg 70% 60%)`;

      playBeep(600, 80, 0.12); // play launch beep

      missiles.push({
        sx, sy, ex, ey, mx, my, progress:0, speed, color, attackerId:attacker.id, targetId:target.id
      });
    }

    function makeExplosion(x,y){
      const parts = [];
      const count = 18;
      for (let i=0;i<count;i++){
        const ang = rand(0, Math.PI*2);
        const sp = rand(40,160); // px per second
        parts.push({x,y,ang,sp,vx:Math.cos(ang)*sp,vy:Math.sin(ang)*sp,life:rand(0.6,1.6)});
      }
      explosions.push({x,y,time:0,parts});
    }

    // ====== Update / Draw ======
    function update(dt, now){
      if (!running) return;

      // Launch control
      if (now - lastLaunchTime > nextLaunchDelay){
        const pick = pickAttackerAndTarget();
        if (pick) launchMissile(pick.attacker, pick.target);
        lastLaunchTime = now;
        nextLaunchDelay = rand(LAUNCH_MIN_MS, LAUNCH_MAX_MS);
      }

      // Update missiles (iterate backwards — we may remove items)
      for (let i = missiles.length - 1; i >= 0; i--){
        const m = missiles[i];
        m.progress += m.speed * dt;
        if (m.progress >= 1){
          // Hit!
          const tx = m.ex;
          const ty = m.ey;
          makeExplosion(tx, ty);
          playExplosion(); // explosion sound

          // mark target dead if alive
          const target = countries.find(c => c.id === m.targetId);
          if (target && target.alive){
            target.alive = false;
            eliminated.push(target.short);
          }
          missiles.splice(i,1);
        }
      }

      // Update explosions
      for (let i = explosions.length - 1; i >= 0; i--){
        const e = explosions[i];
        e.time += dt;
        // update particles
        e.parts.forEach(p => {
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          // slow down
          p.vx *= (1 - dt*1.2);
          p.vy *= (1 - dt*1.2);
        });
        if (e.time > 1.6) explosions.splice(i,1);
      }

      // Check game over
      const aliveCount = countries.filter(c => c.alive).length;
      if (aliveCount <= 1 && running){
        running = false;
        const winner = countries.find(c => c.alive);
        const winnerName = winner ? winner.short : null;
        showResults(winnerName);
        startBtn.disabled = false;
      }
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // draw background map if loaded or a subtle grid
      if (bgLoaded){
        ctx.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);
        // dark overlay for contrast
        ctx.fillStyle = 'rgba(0,0,0,0.28)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
      } else {
        // fallback background
        ctx.fillStyle = '#001';
        ctx.fillRect(0,0,canvas.width,canvas.height);
      }

      // draw missile arcs (faint curves) then moving projectiles
      missiles.forEach(m => {
        // faint full arc path
        ctx.save();
        ctx.globalAlpha = 0.22;
        ctx.strokeStyle = m.color;
        ctx.lineWidth = 2.4;
        ctx.beginPath();
        ctx.moveTo(m.sx, m.sy);
        ctx.quadraticCurveTo(m.mx, m.my, m.ex, m.ey);
        ctx.stroke();
        ctx.restore();

        // current position
        const p = quadraticPoint({x:m.sx,y:m.sy},{x:m.mx,y:m.my},{x:m.ex,y:m.ey}, Math.max(0, Math.min(1,m.progress)));

        // glowing projectile
        ctx.save();
        ctx.shadowColor = m.color;
        ctx.shadowBlur = 18;
        ctx.fillStyle = '#ffd';
        ctx.beginPath();
        ctx.arc(p.x, p.y, 6, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        // small spark
        ctx.fillStyle = m.color;
        ctx.fillRect(p.x-1.5, p.y-1.5, 3,3);
      });

      // draw explosions (particles + ring)
      explosions.forEach(e => {
        // ring
        const alpha = 1 - (e.time / 1.6);
        ctx.save();
        ctx.globalAlpha = 0.8 * alpha;
        const r = 12 + e.time * 90;
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255,230,140,${0.9*alpha})`;
        ctx.lineWidth = 2 + (1-alpha)*4;
        ctx.arc(e.x, e.y, r, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();

        // particles
        e.parts.forEach(p => {
          ctx.save();
          ctx.globalAlpha = Math.max(0, 1 - (e.time / p.life));
          ctx.fillStyle = 'orange';
          ctx.fillRect(p.x-2, p.y-2, 4,4);
          ctx.restore();
        });
      });

      // draw countries/markers and names
      ctx.font = FONT;
      ctx.textBaseline = 'bottom';
      countries.forEach(c => {
        // marker
        ctx.beginPath();
        ctx.fillStyle = c.alive ? 'lime' : 'gray';
        ctx.arc(c.x, c.y, MARKER_RADIUS, 0, Math.PI*2);
        ctx.fill();

        // name with subtle halo for legibility
        const text = c.name;
        const tw = ctx.measureText(text).width;
        const tx = c.x - tw/2;
        const ty = c.y - MARKER_RADIUS - 8;
        // background for text
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(tx-6, ty-16, tw+12, 20);
        ctx.fillStyle = '#fff';
        ctx.fillText(text, tx, ty);
      });

      // HUD - live count
      const alive = countries.filter(c=>c.alive).length;
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(12,12,180,36);
      ctx.fillStyle = '#fff';
      ctx.font = '14px monospace';
      ctx.fillText(`Alive: ${alive}   Missiles: ${missiles.length}`, 20, 36);
    }

    function showResults(winnerShort){
      // Build draft order: winner first, then eliminated in reverse order (last eliminated highest pick)
      const order = [];
      if (winnerShort) order.push(winnerShort);
      const reversed = eliminated.slice().reverse();
      reversed.forEach(n => order.push(n));

      // if some remaining (shouldn't), append
      const others = countries.filter(c => !order.includes(c.short)).map(c => c.short);
      others.forEach(o => order.push(o));

      // show overlay
      overlay.innerHTML = `<h2>Draft Order</h2><div style="text-align:left;margin-top:8px">${order.map((n,i)=>`<div>${i+1}. ${n}</div>`).join('')}</div><div style="margin-top:10px;text-align:center"><button id=closeBtn>Close</button></div>`;
      overlay.style.display = 'block';
      document.getElementById('closeBtn').onclick = ()=>{ overlay.style.display='none'; }
    }

    // ====== Main loop ======
    function frame(now){
      const dt = Math.min(0.033, (now - lastTime) / 1000); // cap dt for stability (max ~33ms)
      update(dt, now);
      draw();
      lastTime = now;
      requestAnimationFrame(frame);
    }

    // ====== Controls ======
    resetBtn.addEventListener('click', ()=>{ resetGame(); });
    startBtn.addEventListener('click', ()=>{
      running = true;
      startBtn.disabled = true;
      // Resume AudioContext on user interaction for sound in some browsers
      if (typeof AudioContext !== 'undefined' && window.audioCtx === undefined) {
        window.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        window.audioCtx.resume();
      }
    });

    // ====== Start ======
    initCountries();
    lastTime = performance.now();
    requestAnimationFrame(frame);

    // expose a simple API in case you want to programmatically start/reset from console
    window.LCS = {reset: resetGame, start: ()=>{running=true}, countries, missiles, explosions};
  })();
  </script>
</body>
</html>
