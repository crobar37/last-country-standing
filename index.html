<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Last Country Standing — Draft Order</title>
  <style>
    html,body{height:100%;margin:0;background:#000;color:#fff;font-family:monospace}
    .wrap{max-width:1200px;margin:14px auto;text-align:center}
    canvas{display:block;margin:12px auto;border:3px solid rgba(255,255,255,0.06);box-shadow:0 8px 30px rgba(0,0,0,0.7)}
    #overlay{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.75);color:#fff;padding:20px;border-radius:8px;display:none;min-width:320px}
    #overlay h2{margin:0 0 10px 0}
    #controls{margin-top:6px}
    button{background:#0b6;padding:8px 12px;border:none;border-radius:6px;cursor:pointer}
    button.secondary{background:#555}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Last Country Standing — Draft Order</h1>
    <canvas id="gameCanvas" width="1000" height="600"></canvas>
    <div id="controls">
      <button id="resetBtn" class="secondary">Reset</button>
      <button id="startBtn">Start</button>
    </div>
  </div>
  <div id="overlay"></div>

  <script>
  (function(){
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const resetBtn = document.getElementById('resetBtn');
    const startBtn = document.getElementById('startBtn');

    // ====== Configurable parameters ======
    const PLAYERS = [
      'Jeff', 'Glenn', 'John', 'Mike', 'Farrad', 'Dave',
      'Allyson', 'Jerry', 'Jim', 'Todd', 'Scott', 'Matt'
    ];

    const COUNTRY_STYLES = [' Republic', 'land', 'stan', 'ovia', ' Isles', ' Federation', ' Dominion'];

    const LAUNCH_MIN_MS = 2600; // min time between launches
    const LAUNCH_MAX_MS = 5100; // max time between launches
    const TRAVEL_MIN_S = 3.6;   // min travel time (seconds)
    const TRAVEL_MAX_S = 6.6;   // max travel time (seconds)

    const FONT = '13px monospace';

    // ====== State ======
    let countries = [];
    let missiles = [];
    let explosions = [];
    let eliminated = []; // elimination order (first eliminated first)
    let running = false;

    let lastTime = performance.now();
    let lastLaunchTime = 0;
    let nextLaunchDelay = rand(LAUNCH_MIN_MS, LAUNCH_MAX_MS);

    // Background world map (Mercator projection)
    const backgroundImg = new Image();
    backgroundImg.crossOrigin = 'anonymous';
    backgroundImg.src = 'https://upload.wikimedia.org/wikipedia/commons/8/80/World_map_-_low_resolution.svg';
    let bgLoaded = false;
    backgroundImg.onload = () => { bgLoaded = true; }

    // ====== Helpers ======
    function rand(min, max){ return Math.random() * (max - min) + min }
    function choice(arr){ return arr[Math.floor(Math.random()*arr.length)] }

    function quadraticPoint(p0,p1,p2,t){
      const u = 1 - t;
      const tt = t*t;
      const uu = u*u;
      return {
        x: uu*p0.x + 2*u*t*p1.x + tt*p2.x,
        y: uu*p0.y + 2*u*t*p1.y + tt*p2.y
      }
    }

    // ====== City Drawing ======
    // Draws a small cluster of varied rectangular "high rises" at (x,y)
    // Each country gets a unique seed to vary shapes/colors
    function drawCity(x, y, seed) {
      const baseWidth = 20;
      const baseHeight = 30;
      const spacing = 5;

      // Simple deterministic pseudo random from seed
      function prng(s) {
        let x = Math.sin(s) * 10000;
        return x - Math.floor(x);
      }

      ctx.save();
      ctx.translate(x, y);

      const numBuildings = 4 + Math.floor(prng(seed) * 3); // 4-6 buildings
      let offsetX = -((numBuildings-1) * (baseWidth + spacing)) / 2;

      for (let i = 0; i < numBuildings; i++) {
        const h = baseHeight * (0.6 + prng(seed + i) * 1.4); // height varies
        const w = baseWidth * (0.6 + prng(seed + i * 7) * 0.8); // width varies

        // Color varies from greenish to blueish for diversity
        const hue = 150 + (prng(seed + i * 13) * 100);
        const lightness = 40 + prng(seed + i * 17) * 30;
        ctx.fillStyle = `hsl(${hue}, 70%, ${lightness}%)`;

        ctx.shadowColor = `hsl(${hue}, 80%, 30%)`;
        ctx.shadowBlur = 3;

        ctx.fillRect(offsetX, -h, w, h);

        // windows (little squares)
        ctx.fillStyle = `hsl(${hue}, 20%, ${Math.min(lightness+40, 90)}%)`;
        const rows = 3 + Math.floor(prng(seed + i * 19) * 4);
        const cols = 2 + Math.floor(prng(seed + i * 23) * 3);
        const winW = w / (cols * 1.5);
        const winH = h / (rows * 2.5);

        for(let r=0; r<rows; r++) {
          for(let c=0; c<cols; c++) {
            if(prng(seed + r*cols + c + i * 29) > 0.5) {
              ctx.fillRect(offsetX + c*winW*1.5 + winW/3, -h + r*winH*2 + winH/3, winW, winH);
            }
          }
        }

        offsetX += w + spacing;
      }
      ctx.restore();
    }

    // ====== Sound Functions ======

    // Simple beep function for 8-bit style sound
    function playBeep(freq=440, duration=120, volume=0.1){
      try {
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        oscillator.type = 'square'; // 8-bit style wave
        oscillator.frequency.value = freq;
        gainNode.gain.value = volume;

        oscillator.start();

        setTimeout(() => {
          oscillator.stop();
          audioCtx.close();
        }, duration);
      } catch(e){ /* ignore on error */ }
    }

    // Explosion sound with noise burst
    function playExplosion(){
      try {
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const bufferSize = audioCtx.sampleRate;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);

        // Fill buffer with white noise fading out
        for(let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
        }

        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;

        const gainNode = audioCtx.createGain();
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);

        noise.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        noise.start();
        noise.stop(audioCtx.currentTime + 0.3);

        setTimeout(() => audioCtx.close(), 500);
      } catch(e){ /* ignore on error */ }
    }

    // ====== Init / Reset ======
    function makeCountryName(base){
      const suf = choice(COUNTRY_STYLES);
      return base + suf;
    }

    function initCountries(){
      countries = [];
      eliminated = [];
      missiles = [];
      explosions = [];

      const cols = 4;
      const rows = Math.ceil(PLAYERS.length / cols);
      const marginX = 80;
      const marginY = 60;
      const xSpacing = (canvas.width - marginX*2) / (cols - 1 || 1);
      const ySpacing = (canvas.height - marginY*2) / (rows - 1 || 1);
      let index = 0;
      for (let r=0; r<rows; r++){
        for (let c=0; c<cols; c++){
          if (index >= PLAYERS.length) break;
          const x = marginX + c * xSpacing;
          const y = marginY + r * ySpacing;
          countries.push({
            id: index,
            name: makeCountryName(PLAYERS[index]),
            short: PLAYERS[index],
            x, y,
            alive: true,
            seed: index * 97 + 41 // unique seed for city drawing variation
          });
          index++;
        }
      }
    }

    function resetGame(){
      running = false;
      initCountries();
      overlay.style.display = 'none';
      lastTime = performance.now();
      lastLaunchTime = lastTime;
      nextLaunchDelay = rand(LAUNCH_MIN_MS, LAUNCH_MAX_MS);
      startBtn.disabled = false;
      draw();
    }

    // ====== Launching / Simulation ======
    function pickAttackerAndTarget(){
      const alive = countries.filter(c=>c.alive);
      if (alive.length <= 1) return null;
      const attacker = choice(alive);
      let target = choice(alive);
      while (target === attacker) target = choice(alive);
      return {attacker, target};
    }

    function launchMissile(attacker, target){
      const sx = attacker.x;
      const sy = attacker.y;
      const ex = target.x;
      const ey = target.y;

      // Control point — make a high arch above the two points, with some randomness
      const mx = (sx + ex) / 2 + rand(-80, 80);
      const my = Math.min(sy, ey) - rand(140, 260); // high arc

      const travel = rand(TRAVEL_MIN_S, TRAVEL_MAX_S); // seconds
      const speed = 1 / travel; // progress per second

      const color = `hsl(${Math.floor(rand(0,360))}deg 70% 60%)`;

      playBeep(600, 80, 0.12); // play launch beep

      missiles.push({

